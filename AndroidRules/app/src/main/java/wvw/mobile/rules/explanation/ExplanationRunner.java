package wvw.mobile.rules.explanation;

import android.util.Log;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;


import com.hp.hpl.jena.graph.Node;
import com.hp.hpl.jena.graph.Triple;
import com.hp.hpl.jena.rdf.model.InfModel;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.ResourceFactory;
import com.hp.hpl.jena.rdf.model.Literal;
import com.hp.hpl.jena.rdf.model.Statement;
import com.hp.hpl.jena.rdf.model.StmtIterator;
import com.hp.hpl.jena.reasoner.Derivation;
import com.hp.hpl.jena.reasoner.rulesys.RuleDerivation;
import com.hp.hpl.jena.util.PrintUtil;

public class ExplanationRunner {


    public static void print(String message) {
        Log.d("Explanation-Runner", message);
    }

    // returns a string with @num tabs in it
    public static String tabOffset(int num) {
        String tab = "";
        for (int i=0; i < num; i++) {
            tab += ("\t");
        }
        return tab;
    }

    public static String printSimpleList(List<Triple> list) {
        String results = "";
        for (Triple t : list) {
            results += t.toString() + "\n";
        }
        return results;
    }

    // A recursive function that traces through the infModel to determine how the statement was generated
    // by a reasoner, if at all. infModel contains the full RDF model including the triples generated by
    // the reasoner, the baseModel just contains the triples inputted by the user. The statement is the
    // triple that we are tracing back. Tabs specifies the formatting, and can be thought of as the "level"
    // in our model that we're in.
    public static String traceDerivation(InfModel infModel, Model baseModel, Statement statement, int tabs) {
        String results = "";

        // Find the triples (matches) and rule that was used to
        // assert this statement, if it exists in the infModel.
        Iterator<Derivation> derivItr = infModel.getDerivation(statement);
        while(derivItr.hasNext()) {

            // Should be the same as statement.
            // Multiple are possible if a wildcard is used within statement.
            RuleDerivation derivation = (RuleDerivation) derivItr.next();

            // The concluded triple:
            Triple conclusion = derivation.getConclusion();
            results += (tabOffset(tabs) + "Conclusion: " + conclusion.toString() + " used the following matches: \n");

            // Goes through the triples that were "matched" with the rule that was fired to
            // generate the concluded triple.
            for (Triple match : derivation.getMatches()) {

                // Use the URIs to generate a statement, so we can search the base model for the statement.
                Resource matchResource = ResourceFactory.createResource(match.getSubject().getURI());
                Property matchProperty = ResourceFactory.createProperty(match.getPredicate().getURI());

                Node obj = match.getObject();

                if (!obj.isLiteral()) {
                    Resource matchObject = ResourceFactory.createResource(match.getObject().getURI());

                    Statement s = ResourceFactory.createStatement(matchResource, matchProperty, matchObject);

                    // If the match was added by the user, we don't need to trace through how the reasoner derived
                    // that statement, since the user added it themselves...
                    if (baseModel.contains(s)) {
                        results += tabOffset(tabs) + " Match: " + s.toString() + " was asserted by the user\n";
                    }

                    // Assuming it's not in the base model, then the reasoner must have derived that statement...
                    if (!baseModel.contains(s)) {
                        results += tabOffset(tabs) + " Match: " + s.toString() + " was asserted by the reasoner.\n";

                        // Recursively trace to find how the reasoner derived that statement.
                        results += traceDerivation(infModel, baseModel, s, tabs+1) + "\n";
                    }
                } else {
                    Literal l = ResourceFactory.createTypedLiteral(obj.getLiteralValue().toString(), obj.getLiteralDatatype());
                    Statement s = ResourceFactory.createStatement(matchResource, matchProperty, l);

                    if (baseModel.contains(s)) {
                        results += tabOffset(tabs) + " Match: " + s.toString() + " was asserted by the user\n";
                    }

                    // Assuming it's not in the base model, then the reasoner must have derived that statement...
                    if (!baseModel.contains(s)) {
                        results += tabOffset(tabs) + " Match: " + s.toString() + " was asserted by the reasoner.\n";

                        // Recursively trace to find how the reasoner derived that statement.
                        results += traceDerivation(infModel, baseModel, s, tabs+1) + "\n";
                    }
                }
            }

            // After going through the matches, we now print the rule that the matches matched to.
            // TODO: Match match triples with the rule to make it more readable?
            results += tabOffset(tabs) + "And paired them with the following rule: \n" ;
            results += tabOffset(tabs) + derivation.getRule().toString() + "\n";
            results += tabOffset(tabs) + "to reach this conclusion.\n";

        }
        return results;
    }

    // Use the generated inf model, to provide a deep trace for a
    // triple (subject : predicate : object). The base model (containing
    // triples not generated by the reasoner) is needed to check whether
    // a statement was generated by the reasoner or inputted by the user.
    public static void printReasoning(Model baseModel, InfModel inf,
                                      Resource subject, Property predicate, RDFNode object) {
        String answer = "";
        StmtIterator stmtItr = inf.listStatements(subject, predicate, object);
        while ( stmtItr.hasNext() )
        {
            Statement s = stmtItr.next();
            answer += traceDerivation(inf, baseModel, s, 0) + "\n";

        }
        print("Hello\n" + answer);
    }

    public static void run () {
        /*
        InfModel infModel = ModelFactory.getAIMEInfModel();
        // Create model...
        PrintUtil.registerPrefix("ex", ModelFactory.getGlobalURI());
        String rules = "[transitiveRule: (?a ex:equals ?b) (?b ex:equals ?c) -> (?a ex:equals ?c)]";
        Explainer explainer = new Explainer();
        explainer.Model(ModelFactory.getTransitiveBaseModel());
        explainer.Rules(rules);

        Resource person  = infModel.getResource(ModelFactory.getPersonURI());
        Property totalSugars = infModel.getProperty("http://example.com/totalSugars");
        Property sugars = infModel.getProperty("http://example.com/sugars");
        Resource observation = infModel.getResource(ModelFactory.getObservavtionURI());

        RDFNode value = null;

        printReasoning(ModelFactory.getAIMEBaseModel(),
                ModelFactory.getAIMEInfModel(),
                person,
                totalSugars,
                value
        );
        */
        // Create model...
        PrintUtil.registerPrefix("ex", ModelFactory.getGlobalURI());
        String rules = "[transitiveRule: (?a ex:equals ?b) (?b ex:equals ?c) -> (?a ex:equals ?c)]";
        Explainer explainer = new Explainer();
        explainer.Model(ModelFactory.getTransitiveBaseModel());
        explainer.Rules(rules);

        String results = explainer.GetShallowContextualExplanation(
                explainer.Model().getResource("A"),
                explainer.Model().getProperty("http://example.com/equals"),
                explainer.Model().getResource("D")
        );

        print("\n" + results);
        results = explainer.GetSimpleContextualExplanation(
                explainer.Model().getResource("A"),
                explainer.Model().getProperty("http://example.com/equals"),
                explainer.Model().getResource("D")
        );

        //print("\n" + results);
        Explainer explainer2 = new Explainer();
        explainer2.Model(ModelFactory.getAIMEBaseModel());
        explainer2.Rules(ModelFactory.getAIMERules());

        InfModel infModel = ModelFactory.getAIMEInfModel();

        Resource person  = infModel.getResource(ModelFactory.getPersonURI());
        Property totalSugars = infModel.getProperty("http://example.com/totalSugars");

        StmtIterator itr = infModel.listStatements(person, totalSugars, (RDFNode) null);

        String res = "AIME_Explainer -- ContrastiveExplanation\n";
        while(itr.hasNext()) {
            Statement s = itr.next();
            res += explainer2.GetFullCounterfactualExplanation(s, ModelFactory.getAIMEBaseModelBanana());
        }
        print(res);
    }
}